// Package tree provides the functions for creating and managing an iden3 merkletree
package gravitontree

import (
	"fmt"
	"path"
	"sync/atomic"
	"time"

	"git.sr.ht/~sircmpwn/go-bare"
	"go.vocdoni.io/dvote/censustree"
	"go.vocdoni.io/dvote/crypto/ethereum"
	"go.vocdoni.io/dvote/log"
	"go.vocdoni.io/dvote/statedb"
	"go.vocdoni.io/dvote/statedb/gravitonstate"
	"go.vocdoni.io/proto/build/go/models"
)

// We use go-bare for export/import the trie. In order to support
// big census (up to 8 Million entries) we need to increase the maximums.
const bareMaxArrayLength uint64 = 1024 * 1014 * 8 // 8 Million

const bareMaxUnmarshalBytes uint64 = bareMaxArrayLength * 32 // 256 MiB

type Tree struct {
	Tree           statedb.StateTree
	store          statedb.StateDB
	dataDir        string
	name           string
	public         uint32
	lastAccessUnix int64 // a unix timestamp, used via sync/atomic
	censusType     models.Census_Type
}

// check that censustree.Tree interface is matched by Tree
var _ censustree.Tree = (*Tree)(nil)

type exportElement struct {
	Key   []byte `bare:"key"`
	Value []byte `bare:"value"`
}

type exportData struct {
	Elements []exportElement `bare:"elements"`
}

const (
	MaxKeySize   = 65
	MaxValueSize = 65
)

// NewTree opens or creates a merkle tree under the given storage.
// Note that each tree should use an entirely separate namespace for its database keys.
func NewTree(name, storageDir string) (censustree.Tree, error) {
	gs := new(gravitonstate.GravitonState)
	// Graviton tree name does not support more than 32 chars
	// So we make a hash of the provided name and truncate it to 32
	iname := fmt.Sprintf("%x", ethereum.HashRaw([]byte(name)))[:32]
	dir := path.Join(storageDir, iname)
	log.Debugf("creating census tree %s on %s", iname, dir)

	if err := gs.Init(dir, "disk"); err != nil {
		return nil, err
	}
	if err := gs.AddTree(iname); err != nil {
		return nil, err
	}
	if err := gs.LoadVersion(0); err != nil {
		return nil, err
	}
	tr := &Tree{store: gs, Tree: gs.Tree(iname), name: iname, dataDir: dir,
		censusType: models.Census_GRAVITON}
	tr.updateAccessTime()
	return tr, nil
}

// Init initializes the Tree using the given storage directory.
func (t *Tree) Init(name, storageDir string) error {
	ct, err := NewTree(name, storageDir)
	if err != nil {
		return err
	}
	t.store = ct.(*Tree).store
	t.name = ct.(*Tree).name
	t.Tree = ct.(*Tree).Tree
	t.dataDir = ct.(*Tree).dataDir
	t.censusType = models.Census_GRAVITON
	t.updateAccessTime()
	return nil
}

// Type returns the numeric identifier of the censustree implementation
func (t *Tree) Type() models.Census_Type {
	return t.censusType
}

// TypeString returns the name identifying the censustree implementation
func (t *Tree) TypeString() string {
	return models.Census_Type_name[int32(t.censusType)] // reuse the naming generated by protobuf
}

// MaxKeySize returns the maximum key size supported by the Tree
func (t *Tree) MaxKeySize() int {
	return MaxKeySize
}

// LastAccess returns the last time the Tree was accessed, in the form of a unix
// timestamp.
func (t *Tree) LastAccess() int64 {
	return atomic.LoadInt64(&t.lastAccessUnix)
}

func (t *Tree) updateAccessTime() {
	atomic.StoreInt64(&t.lastAccessUnix, time.Now().Unix())
}

// Publish makes a merkle tree available for queries.
// Application layer should check IsPublish() before considering the Tree available.
func (t *Tree) Publish() {
	atomic.StoreUint32(&t.public, 1)
}

// UnPublish makes a merkle tree not available for queries
func (t *Tree) UnPublish() {
	atomic.StoreUint32(&t.public, 0)
}

// IsPublic returns true if the tree is available
func (t *Tree) IsPublic() bool {
	return atomic.LoadUint32(&t.public) == 1
}

// Add adds a new leaf to the merkle tree
// A claim is composed of two parts: index and value
//  1.index is mandatory, the data will be used for indexing the claim into to merkle tree
//  2.value is optional, the data will not affect the indexing
func (t *Tree) Add(index, value []byte) error {
	t.updateAccessTime()
	if len(index) < 4 {
		return fmt.Errorf("claim index too small (%d), minimum size is 4 bytes", len(index))
	}
	if len(index) > MaxKeySize || len(value) > MaxValueSize {
		return fmt.Errorf("index or value claim data too big")
	}
	if err := t.Tree.Add(index, value); err != nil {
		return err
	}

	_, err := t.store.Commit()
	return err
}

// AddBatch adds a list of indexes and values to the tree. Only commits at the end.
func (t *Tree) AddBatch(indexes, values [][]byte) ([]int, error) {
	t.updateAccessTime()
	var wrongIndexes []int
	if len(values) > 0 && len(indexes) != len(values) {
		return wrongIndexes, fmt.Errorf("indexes and values have different size")
	}
	for i, key := range indexes {
		if len(key) < 4 || len(key) > MaxKeySize {
			log.Debugf("addBatch: invalid key size: %d", len(key))
			wrongIndexes = append(wrongIndexes, i)
			continue
		}
		if len(values) > 0 {
			if err := t.Tree.Add(key, values[i]); err != nil {
				log.Debugf("addBatch: invalid value size: %d", len(key))
				wrongIndexes = append(wrongIndexes, i)
				continue
			}
		} else {
			if err := t.Tree.Add(key, nil); err != nil {
				wrongIndexes = append(wrongIndexes, i)
				continue
			}
		}
	}
	_, err := t.store.Commit()
	return wrongIndexes, err
}

// GenProof generates a merkle tree proof that can be later used on CheckProof() to validate it
func (t *Tree) GenProof(index, value []byte) ([]byte, error) {
	t.updateAccessTime()
	proof, err := t.Tree.Proof(index)
	if err != nil {
		return nil, err
	}
	return proof, nil
}

// CheckProof standalone function for checking a merkle proof
func CheckProof(index, value, root []byte, mproof []byte) (bool, error) {
	if len(index) > gravitonstate.GravitonMaxKeySize {
		return false, fmt.Errorf("index is too big, maximum allowed is %d",
			gravitonstate.GravitonMaxKeySize)
	}
	if len(value) > gravitonstate.GravitonMaxValueSize {
		return false, fmt.Errorf("value is too big, maximum allowed is %d",
			gravitonstate.GravitonMaxValueSize)
	}
	if len(root) != gravitonstate.GravitonHashSizeBytes {
		return false, fmt.Errorf("root hash length is incorrect (expected %d)",
			gravitonstate.GravitonHashSizeBytes)
	}
	return gravitonstate.Verify(index, value, mproof, root)
}

// CheckProof validates a merkle proof and its data
func (t *Tree) CheckProof(index, value, root, mproof []byte) (bool, error) {
	if len(index) > gravitonstate.GravitonMaxKeySize {
		return false, fmt.Errorf("index is too big, maximum allowed is %d",
			gravitonstate.GravitonMaxKeySize)
	}
	if len(value) > gravitonstate.GravitonMaxValueSize {
		return false, fmt.Errorf("value is too big, maximum allowed is %d",
			gravitonstate.GravitonMaxValueSize)
	}
	if t.Tree == nil {
		return false, fmt.Errorf("tree %s does not exist", t.name)
	}
	t.updateAccessTime()
	return t.Tree.Verify(index, value, mproof, root), nil
}

// Root returns the current root hash of the merkle tree
func (t *Tree) Root() ([]byte, error) {
	t.updateAccessTime()
	return t.Tree.Hash(), nil
}

func (t *Tree) treeWithRoot(root []byte) statedb.StateTree {
	if root == nil {
		return t.Tree
	}
	return t.store.TreeWithRoot(root)
}

// Dump returns the whole merkle tree serialized in a format that can be used on Import.
// Byte seralization is performed using bare message protocol, it is a 40% size win over JSON
func (t *Tree) Dump(root []byte) ([]byte, error) {
	t.updateAccessTime()
	tree := t.treeWithRoot(root)
	if tree == nil {
		return nil, fmt.Errorf("dump: root not found %x", root)
	}
	dump := exportData{}
	tree.Iterate(nil, func(k, v []byte) bool {
		ee := exportElement{Key: make([]byte, len(k)), Value: make([]byte, len(v))}
		// Copy elements since it's not safe to hold on to the []byte values from Iterate
		copy(ee.Key, k[:])
		copy(ee.Value, v[:])
		dump.Elements = append(dump.Elements, ee)
		return false
	})
	bare.MaxArrayLength(bareMaxArrayLength)
	bare.MaxUnmarshalBytes(bareMaxUnmarshalBytes)

	return bare.Marshal(&dump)
}

// Size returns the number of leaf nodes on the merkle tree
func (t *Tree) Size(root []byte) (int64, error) {
	tree := t.treeWithRoot(root)
	if tree == nil {
		return 0, nil
	}
	return int64(tree.Count()), nil
}

// DumpPlain returns the entire list of added claims for a specific root hash
// First return parametre are the indexes and second the values
// If root is not specified, the current one is used
// If responseBase64 is true, the list will be returned base64 encoded
func (t *Tree) DumpPlain(root []byte) ([][]byte, [][]byte, error) {
	var indexes, values [][]byte
	var err error
	t.updateAccessTime()

	tree := t.treeWithRoot(root)
	if tree == nil {
		return nil, nil, fmt.Errorf("DumpPlain: root not found %x", root)
	}
	tree.Iterate(nil, func(k, v []byte) bool {
		indexes = append(indexes, k)
		values = append(values, v)
		return false
	})

	return indexes, values, err
}

// ImportDump imports a partial or whole tree previously exported with Dump()
func (t *Tree) ImportDump(data []byte) error {
	t.updateAccessTime()
	census := new(exportData)
	bare.MaxArrayLength(bareMaxArrayLength)
	bare.MaxUnmarshalBytes(bareMaxUnmarshalBytes)
	if err := bare.Unmarshal(data, census); err != nil {
		return fmt.Errorf("importdump cannot unmarshal data: %w", err)
	}
	for _, ee := range census.Elements {
		if err := t.Tree.Add(ee.Key, ee.Value); err != nil {
			return err
		}
	}
	_, err := t.store.Commit()
	return err
}

// Snapshot returns a Tree instance of a exiting merkle root
func (t *Tree) Snapshot(root []byte) (censustree.Tree, error) {
	tree := t.treeWithRoot(root)
	if tree == nil {
		return nil, fmt.Errorf("snapshot: root not valid or not found %s", root)
	}
	return &Tree{store: t.store, Tree: tree, public: t.public}, nil
}

// HashExists checks if a hash exists as a node in the merkle tree
func (t *Tree) HashExists(hash []byte) (bool, error) {
	t.updateAccessTime()
	tree := t.treeWithRoot(hash)
	if tree == nil {
		return false, nil
	}
	return true, nil
}
