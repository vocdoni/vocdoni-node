// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: processes.sql

package indexerdb

import (
	"context"
	"database/sql"
	"time"

	"go.vocdoni.io/dvote/types"
)

const computeProcessVoteCount = `-- name: ComputeProcessVoteCount :execresult
UPDATE processes
SET vote_count = (SELECT COUNT(*) FROM votes WHERE process_id = id)
WHERE id = ?1
`

func (q *Queries) ComputeProcessVoteCount(ctx context.Context, id types.ProcessID) (sql.Result, error) {
	return q.exec(ctx, q.computeProcessVoteCountStmt, computeProcessVoteCount, id)
}

const createProcess = `-- name: CreateProcess :execresult
INSERT INTO processes (
	id, entity_id, start_date, end_date, manually_ended,
	title, description,
	vote_count, have_results, final_results, census_root,
	max_census_size, census_uri, metadata,
	census_origin, status, namespace,
	envelope, mode, vote_opts,
	private_keys, public_keys,
	question_index, creation_time,
	source_block_height, source_network_id,
	chain_id,

	results_votes, results_weight, results_block_height
) VALUES (
	?, ?, ?, ?, ?,
	?, ?,
	?, ?, ?, ?,
	?, ?, ?,
	?, ?, ?,
	?, ?, ?,
	?, ?,
	?, ?,
	?, ?,
	?,

	?, '"0"', 0
)
`

type CreateProcessParams struct {
	ID                types.ProcessID
	EntityID          types.EntityID
	StartDate         time.Time
	EndDate           time.Time
	ManuallyEnded     bool
	Title             string
	Description       string
	VoteCount         int64
	HaveResults       bool
	FinalResults      bool
	CensusRoot        types.CensusRoot
	MaxCensusSize     int64
	CensusUri         string
	Metadata          string
	CensusOrigin      int64
	Status            int64
	Namespace         int64
	Envelope          []byte
	Mode              []byte
	VoteOpts          []byte
	PrivateKeys       string
	PublicKeys        string
	QuestionIndex     int64
	CreationTime      time.Time
	SourceBlockHeight int64
	SourceNetworkID   int64
	ChainID           string
	ResultsVotes      string
}

func (q *Queries) CreateProcess(ctx context.Context, arg CreateProcessParams) (sql.Result, error) {
	return q.exec(ctx, q.createProcessStmt, createProcess,
		arg.ID,
		arg.EntityID,
		arg.StartDate,
		arg.EndDate,
		arg.ManuallyEnded,
		arg.Title,
		arg.Description,
		arg.VoteCount,
		arg.HaveResults,
		arg.FinalResults,
		arg.CensusRoot,
		arg.MaxCensusSize,
		arg.CensusUri,
		arg.Metadata,
		arg.CensusOrigin,
		arg.Status,
		arg.Namespace,
		arg.Envelope,
		arg.Mode,
		arg.VoteOpts,
		arg.PrivateKeys,
		arg.PublicKeys,
		arg.QuestionIndex,
		arg.CreationTime,
		arg.SourceBlockHeight,
		arg.SourceNetworkID,
		arg.ChainID,
		arg.ResultsVotes,
	)
}

const getEntityCount = `-- name: GetEntityCount :one
SELECT COUNT(DISTINCT entity_id) FROM processes
`

func (q *Queries) GetEntityCount(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.getEntityCountStmt, getEntityCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getProcess = `-- name: GetProcess :one
SELECT id, entity_id, start_date, end_date, vote_count, chain_id, have_results, final_results, results_votes, results_weight, results_block_height, census_root, max_census_size, census_uri, metadata, census_origin, status, namespace, envelope, mode, vote_opts, private_keys, public_keys, question_index, creation_time, source_block_height, source_network_id, manually_ended, title, description FROM processes
WHERE id = ?
LIMIT 1
`

func (q *Queries) GetProcess(ctx context.Context, id types.ProcessID) (Process, error) {
	row := q.queryRow(ctx, q.getProcessStmt, getProcess, id)
	var i Process
	err := row.Scan(
		&i.ID,
		&i.EntityID,
		&i.StartDate,
		&i.EndDate,
		&i.VoteCount,
		&i.ChainID,
		&i.HaveResults,
		&i.FinalResults,
		&i.ResultsVotes,
		&i.ResultsWeight,
		&i.ResultsBlockHeight,
		&i.CensusRoot,
		&i.MaxCensusSize,
		&i.CensusUri,
		&i.Metadata,
		&i.CensusOrigin,
		&i.Status,
		&i.Namespace,
		&i.Envelope,
		&i.Mode,
		&i.VoteOpts,
		&i.PrivateKeys,
		&i.PublicKeys,
		&i.QuestionIndex,
		&i.CreationTime,
		&i.SourceBlockHeight,
		&i.SourceNetworkID,
		&i.ManuallyEnded,
		&i.Title,
		&i.Description,
	)
	return i, err
}

const getProcessCount = `-- name: GetProcessCount :one
SELECT COUNT(*) FROM processes
`

func (q *Queries) GetProcessCount(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.getProcessCountStmt, getProcessCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getProcessIDsByFinalResults = `-- name: GetProcessIDsByFinalResults :many
SELECT id FROM processes
WHERE final_results = ?
`

func (q *Queries) GetProcessIDsByFinalResults(ctx context.Context, finalResults bool) ([]types.ProcessID, error) {
	rows, err := q.query(ctx, q.getProcessIDsByFinalResultsStmt, getProcessIDsByFinalResults, finalResults)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []types.ProcessID
	for rows.Next() {
		var id types.ProcessID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProcessStatus = `-- name: GetProcessStatus :one
SELECT status FROM processes
WHERE id = ?
LIMIT 1
`

func (q *Queries) GetProcessStatus(ctx context.Context, id types.ProcessID) (int64, error) {
	row := q.queryRow(ctx, q.getProcessStatusStmt, getProcessStatus, id)
	var status int64
	err := row.Scan(&status)
	return status, err
}

const searchEntities = `-- name: SearchEntities :many
WITH results AS (
    SELECT id, entity_id, start_date, end_date, vote_count, chain_id, have_results, final_results, results_votes, results_weight, results_block_height, census_root, max_census_size, census_uri, metadata, census_origin, status, namespace, envelope, mode, vote_opts, private_keys, public_keys, question_index, creation_time, source_block_height, source_network_id, manually_ended, title, description
    FROM processes
    WHERE (?3 = '' OR (INSTR(LOWER(HEX(entity_id)), ?3) > 0))
)
SELECT entity_id,
	COUNT(id) AS process_count,
	COUNT(entity_id) OVER() AS total_count
FROM results
GROUP BY entity_id
ORDER BY creation_time DESC, id ASC
LIMIT ?2
OFFSET ?1
`

type SearchEntitiesParams struct {
	Offset         int64
	Limit          int64
	EntityIDSubstr interface{}
}

type SearchEntitiesRow struct {
	EntityID     []byte
	ProcessCount int64
	TotalCount   int64
}

func (q *Queries) SearchEntities(ctx context.Context, arg SearchEntitiesParams) ([]SearchEntitiesRow, error) {
	rows, err := q.query(ctx, q.searchEntitiesStmt, searchEntities, arg.Offset, arg.Limit, arg.EntityIDSubstr)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchEntitiesRow
	for rows.Next() {
		var i SearchEntitiesRow
		if err := rows.Scan(&i.EntityID, &i.ProcessCount, &i.TotalCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProcesses = `-- name: SearchProcesses :many
WITH results AS (
	SELECT id, entity_id, start_date, end_date, vote_count, chain_id, have_results, final_results, results_votes, results_weight, results_block_height, census_root, max_census_size, census_uri, metadata, census_origin, status, namespace, envelope, mode, vote_opts, private_keys, public_keys, question_index, creation_time, source_block_height, source_network_id, manually_ended, title, description,
			COUNT(*) OVER() AS total_count
	FROM processes
	WHERE (
		LENGTH(?3) <= 40 -- if passed arg is longer, then just abort the query
		AND (
			?3 = ''
			OR (LENGTH(?3) = 40 AND LOWER(HEX(entity_id)) = LOWER(?3))
			OR (LENGTH(?3) < 40 AND INSTR(LOWER(HEX(entity_id)), LOWER(?3)) > 0)
			-- TODO: consider keeping an entity_id_hex column for faster searches
		)
		-- TODO: replace this simple INSTR of title and description with something better
		-- like https://www.sqlite.org/fts5.html
		AND (?4 = '' OR INSTR(LOWER(title), LOWER(?4)) > 0)
		AND (?5 = '' OR INSTR(LOWER(description), LOWER(?5)) > 0)
		AND (?6 = 0 OR namespace = ?6)
		AND (?7 = 0 OR status = ?7)
		AND (?8 = 0 OR source_network_id = ?8)
		AND LENGTH(?9) <= 64 -- if passed arg is longer, then just abort the query
		AND (
			?9 = ''
			OR (LENGTH(?9) = 64 AND LOWER(HEX(id)) = LOWER(?9))
			OR (LENGTH(?9) < 64 AND INSTR(LOWER(HEX(id)), LOWER(?9)) > 0)
			-- TODO: consider keeping an id_hex column for faster searches
		)
		AND (
			?10 = -1
			OR (?10 = 1 AND have_results = TRUE)
			OR (?10 = 0 AND have_results = FALSE)
		)
		AND (
			?11 = -1
			OR (?11 = 1 AND final_results = TRUE)
			OR (?11 = 0 AND final_results = FALSE)
		)
		AND (
			?12 = -1
			OR (?12 = 1 AND manually_ended = TRUE)
			OR (?12 = 0 AND manually_ended = FALSE)
		)
		AND (?13 IS NULL OR start_date >= ?13)
		AND (?14 IS NULL OR start_date <= ?14)
		AND (?15 IS NULL OR end_date >= ?15)
		AND (?16 IS NULL OR end_date <= ?16)
	)
)
SELECT id, total_count
FROM results
ORDER BY creation_time DESC, id ASC
LIMIT ?2
OFFSET ?1
`

type SearchProcessesParams struct {
	Offset          int64
	Limit           int64
	EntityIDSubstr  interface{}
	Title           interface{}
	Description     interface{}
	Namespace       interface{}
	Status          interface{}
	SourceNetworkID interface{}
	IDSubstr        interface{}
	HaveResults     interface{}
	FinalResults    interface{}
	ManuallyEnded   interface{}
	StartDateAfter  interface{}
	StartDateBefore interface{}
	EndDateAfter    interface{}
	EndDateBefore   interface{}
}

type SearchProcessesRow struct {
	ID         []byte
	TotalCount int64
}

func (q *Queries) SearchProcesses(ctx context.Context, arg SearchProcessesParams) ([]SearchProcessesRow, error) {
	rows, err := q.query(ctx, q.searchProcessesStmt, searchProcesses,
		arg.Offset,
		arg.Limit,
		arg.EntityIDSubstr,
		arg.Title,
		arg.Description,
		arg.Namespace,
		arg.Status,
		arg.SourceNetworkID,
		arg.IDSubstr,
		arg.HaveResults,
		arg.FinalResults,
		arg.ManuallyEnded,
		arg.StartDateAfter,
		arg.StartDateBefore,
		arg.EndDateAfter,
		arg.EndDateBefore,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchProcessesRow
	for rows.Next() {
		var i SearchProcessesRow
		if err := rows.Scan(&i.ID, &i.TotalCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setProcessResultsCancelled = `-- name: SetProcessResultsCancelled :execresult
UPDATE processes
SET have_results = FALSE, final_results = TRUE, 
    end_date = ?1,
	manually_ended = ?2
WHERE id = ?3
`

type SetProcessResultsCancelledParams struct {
	EndDate       time.Time
	ManuallyEnded bool
	ID            types.ProcessID
}

func (q *Queries) SetProcessResultsCancelled(ctx context.Context, arg SetProcessResultsCancelledParams) (sql.Result, error) {
	return q.exec(ctx, q.setProcessResultsCancelledStmt, setProcessResultsCancelled, arg.EndDate, arg.ManuallyEnded, arg.ID)
}

const setProcessResultsReady = `-- name: SetProcessResultsReady :execresult
UPDATE processes
SET have_results = TRUE, final_results = TRUE,
	results_votes = ?1,
	results_weight = ?2,
	results_block_height = ?3,
	end_date = ?4
WHERE id = ?5
`

type SetProcessResultsReadyParams struct {
	Votes       string
	Weight      string
	BlockHeight int64
	EndDate     time.Time
	ID          types.ProcessID
}

func (q *Queries) SetProcessResultsReady(ctx context.Context, arg SetProcessResultsReadyParams) (sql.Result, error) {
	return q.exec(ctx, q.setProcessResultsReadyStmt, setProcessResultsReady,
		arg.Votes,
		arg.Weight,
		arg.BlockHeight,
		arg.EndDate,
		arg.ID,
	)
}

const updateProcessEndDate = `-- name: UpdateProcessEndDate :execresult
UPDATE processes
SET end_date = ?1,
	manually_ended = ?2
WHERE id = ?3
`

type UpdateProcessEndDateParams struct {
	EndDate       time.Time
	ManuallyEnded bool
	ID            types.ProcessID
}

func (q *Queries) UpdateProcessEndDate(ctx context.Context, arg UpdateProcessEndDateParams) (sql.Result, error) {
	return q.exec(ctx, q.updateProcessEndDateStmt, updateProcessEndDate, arg.EndDate, arg.ManuallyEnded, arg.ID)
}

const updateProcessFromState = `-- name: UpdateProcessFromState :execresult
UPDATE processes
SET census_root         = ?1,
	census_uri          = ?2,
	private_keys        = ?3,
	public_keys         = ?4,
	metadata            = ?5,
	status              = ?6,
	max_census_size	 	= ?7,
	end_date 			= ?8
WHERE id = ?9
`

type UpdateProcessFromStateParams struct {
	CensusRoot    types.CensusRoot
	CensusUri     string
	PrivateKeys   string
	PublicKeys    string
	Metadata      string
	Status        int64
	MaxCensusSize int64
	EndDate       time.Time
	ID            types.ProcessID
}

func (q *Queries) UpdateProcessFromState(ctx context.Context, arg UpdateProcessFromStateParams) (sql.Result, error) {
	return q.exec(ctx, q.updateProcessFromStateStmt, updateProcessFromState,
		arg.CensusRoot,
		arg.CensusUri,
		arg.PrivateKeys,
		arg.PublicKeys,
		arg.Metadata,
		arg.Status,
		arg.MaxCensusSize,
		arg.EndDate,
		arg.ID,
	)
}

const updateProcessResultByID = `-- name: UpdateProcessResultByID :execresult
UPDATE processes
SET results_votes  = ?1,
    results_weight = ?2,
    vote_opts = ?3,
    envelope = ?4
WHERE id = ?5
`

type UpdateProcessResultByIDParams struct {
	Votes    string
	Weight   string
	VoteOpts []byte
	Envelope []byte
	ID       types.ProcessID
}

func (q *Queries) UpdateProcessResultByID(ctx context.Context, arg UpdateProcessResultByIDParams) (sql.Result, error) {
	return q.exec(ctx, q.updateProcessResultByIDStmt, updateProcessResultByID,
		arg.Votes,
		arg.Weight,
		arg.VoteOpts,
		arg.Envelope,
		arg.ID,
	)
}

const updateProcessResults = `-- name: UpdateProcessResults :execresult
UPDATE processes
SET results_votes = ?1,
	results_weight = ?2,
	results_block_height = ?3
WHERE id = ?4 AND final_results = FALSE
`

type UpdateProcessResultsParams struct {
	Votes       string
	Weight      string
	BlockHeight int64
	ID          types.ProcessID
}

func (q *Queries) UpdateProcessResults(ctx context.Context, arg UpdateProcessResultsParams) (sql.Result, error) {
	return q.exec(ctx, q.updateProcessResultsStmt, updateProcessResults,
		arg.Votes,
		arg.Weight,
		arg.BlockHeight,
		arg.ID,
	)
}
