// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: processes.sql

package indexerdb

import (
	"context"
	"database/sql"
	"time"

	"go.vocdoni.io/dvote/types"
)

const computeProcessVoteCount = `-- name: ComputeProcessVoteCount :execresult
UPDATE processes
SET vote_count = (SELECT COUNT(*) FROM votes WHERE process_id = id)
WHERE id = ?1
`

func (q *Queries) ComputeProcessVoteCount(ctx context.Context, id types.ProcessID) (sql.Result, error) {
	return q.exec(ctx, q.computeProcessVoteCountStmt, computeProcessVoteCount, id)
}

const createProcess = `-- name: CreateProcess :execresult
INSERT INTO processes (
	id, entity_id, start_date, end_date, manually_ended,
	vote_count, have_results, final_results, census_root,
	max_census_size, census_uri, metadata,
	census_origin, status, namespace,
	envelope, mode, vote_opts,
	private_keys, public_keys,
	question_index, creation_time,
	source_block_height, source_network_id,
	chain_id,

	results_votes, results_weight, results_block_height
) VALUES (
	?, ?, ?, ?, ?,
	?, ?, ?, ?,
	?, ?, ?,
	?, ?, ?,
	?, ?, ?,
	?, ?,
	?, ?,
	?, ?,
	?,

	?, '"0"', 0
)
`

type CreateProcessParams struct {
	ID                types.ProcessID
	EntityID          types.EntityID
	StartDate         time.Time
	EndDate           time.Time
	ManuallyEnded     bool
	VoteCount         int64
	HaveResults       bool
	FinalResults      bool
	CensusRoot        types.CensusRoot
	MaxCensusSize     int64
	CensusUri         string
	Metadata          string
	CensusOrigin      int64
	Status            int64
	Namespace         int64
	Envelope          []byte
	Mode              []byte
	VoteOpts          []byte
	PrivateKeys       string
	PublicKeys        string
	QuestionIndex     int64
	CreationTime      time.Time
	SourceBlockHeight int64
	SourceNetworkID   int64
	ChainID           string
	ResultsVotes      string
}

func (q *Queries) CreateProcess(ctx context.Context, arg CreateProcessParams) (sql.Result, error) {
	return q.exec(ctx, q.createProcessStmt, createProcess,
		arg.ID,
		arg.EntityID,
		arg.StartDate,
		arg.EndDate,
		arg.ManuallyEnded,
		arg.VoteCount,
		arg.HaveResults,
		arg.FinalResults,
		arg.CensusRoot,
		arg.MaxCensusSize,
		arg.CensusUri,
		arg.Metadata,
		arg.CensusOrigin,
		arg.Status,
		arg.Namespace,
		arg.Envelope,
		arg.Mode,
		arg.VoteOpts,
		arg.PrivateKeys,
		arg.PublicKeys,
		arg.QuestionIndex,
		arg.CreationTime,
		arg.SourceBlockHeight,
		arg.SourceNetworkID,
		arg.ChainID,
		arg.ResultsVotes,
	)
}

const getEntityCount = `-- name: GetEntityCount :one
SELECT COUNT(DISTINCT entity_id) FROM processes
`

func (q *Queries) GetEntityCount(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.getEntityCountStmt, getEntityCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getProcess = `-- name: GetProcess :one
SELECT id, entity_id, start_date, end_date, vote_count, chain_id, have_results, final_results, results_votes, results_weight, results_block_height, census_root, max_census_size, census_uri, metadata, census_origin, status, namespace, envelope, mode, vote_opts, private_keys, public_keys, question_index, creation_time, source_block_height, source_network_id, manually_ended FROM processes
WHERE id = ?
LIMIT 1
`

func (q *Queries) GetProcess(ctx context.Context, id types.ProcessID) (Process, error) {
	row := q.queryRow(ctx, q.getProcessStmt, getProcess, id)
	var i Process
	err := row.Scan(
		&i.ID,
		&i.EntityID,
		&i.StartDate,
		&i.EndDate,
		&i.VoteCount,
		&i.ChainID,
		&i.HaveResults,
		&i.FinalResults,
		&i.ResultsVotes,
		&i.ResultsWeight,
		&i.ResultsBlockHeight,
		&i.CensusRoot,
		&i.MaxCensusSize,
		&i.CensusUri,
		&i.Metadata,
		&i.CensusOrigin,
		&i.Status,
		&i.Namespace,
		&i.Envelope,
		&i.Mode,
		&i.VoteOpts,
		&i.PrivateKeys,
		&i.PublicKeys,
		&i.QuestionIndex,
		&i.CreationTime,
		&i.SourceBlockHeight,
		&i.SourceNetworkID,
		&i.ManuallyEnded,
	)
	return i, err
}

const getProcessCount = `-- name: GetProcessCount :one
SELECT COUNT(*) FROM processes
`

func (q *Queries) GetProcessCount(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.getProcessCountStmt, getProcessCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getProcessIDsByFinalResults = `-- name: GetProcessIDsByFinalResults :many
SELECT id FROM processes
WHERE final_results = ?
`

func (q *Queries) GetProcessIDsByFinalResults(ctx context.Context, finalResults bool) ([]types.ProcessID, error) {
	rows, err := q.query(ctx, q.getProcessIDsByFinalResultsStmt, getProcessIDsByFinalResults, finalResults)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []types.ProcessID
	for rows.Next() {
		var id types.ProcessID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProcessStatus = `-- name: GetProcessStatus :one
SELECT status FROM processes
WHERE id = ?
LIMIT 1
`

func (q *Queries) GetProcessStatus(ctx context.Context, id types.ProcessID) (int64, error) {
	row := q.queryRow(ctx, q.getProcessStatusStmt, getProcessStatus, id)
	var status int64
	err := row.Scan(&status)
	return status, err
}

const searchEntities = `-- name: SearchEntities :many
WITH results AS (
    SELECT id, entity_id, start_date, end_date, vote_count, chain_id, have_results, final_results, results_votes, results_weight, results_block_height, census_root, max_census_size, census_uri, metadata, census_origin, status, namespace, envelope, mode, vote_opts, private_keys, public_keys, question_index, creation_time, source_block_height, source_network_id, manually_ended
    FROM processes
    WHERE (?3 = '' OR (INSTR(LOWER(HEX(entity_id)), ?3) > 0))
)
SELECT entity_id,
	COUNT(id) AS process_count,
	COUNT(entity_id) OVER() AS total_count
FROM results
GROUP BY entity_id
ORDER BY creation_time DESC, id ASC
LIMIT ?2
OFFSET ?1
`

type SearchEntitiesParams struct {
	Offset         int64
	Limit          int64
	EntityIDSubstr interface{}
}

type SearchEntitiesRow struct {
	EntityID     []byte
	ProcessCount int64
	TotalCount   int64
}

func (q *Queries) SearchEntities(ctx context.Context, arg SearchEntitiesParams) ([]SearchEntitiesRow, error) {
	rows, err := q.query(ctx, q.searchEntitiesStmt, searchEntities, arg.Offset, arg.Limit, arg.EntityIDSubstr)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchEntitiesRow
	for rows.Next() {
		var i SearchEntitiesRow
		if err := rows.Scan(&i.EntityID, &i.ProcessCount, &i.TotalCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProcesses = `-- name: SearchProcesses :many
WITH results AS (
	SELECT id, entity_id, start_date, end_date, vote_count, chain_id, have_results, final_results, results_votes, results_weight, results_block_height, census_root, max_census_size, census_uri, metadata, census_origin, status, namespace, envelope, mode, vote_opts, private_keys, public_keys, question_index, creation_time, source_block_height, source_network_id, manually_ended,
			COUNT(*) OVER() AS total_count
	FROM processes
	WHERE (
		LENGTH(?3) <= 40 -- if passed arg is longer, then just abort the query
		AND (
			?3 = ''
			OR (LENGTH(?3) = 40 AND LOWER(HEX(entity_id)) = LOWER(?3))
			OR (LENGTH(?3) < 40 AND INSTR(LOWER(HEX(entity_id)), LOWER(?3)) > 0)
			-- TODO: consider keeping an entity_id_hex column for faster searches
		)
		AND (?4 = 0 OR namespace = ?4)
		AND (?5 = 0 OR status = ?5)
		AND (?6 = 0 OR source_network_id = ?6)
		AND LENGTH(?7) <= 64 -- if passed arg is longer, then just abort the query
		AND (
			?7 = ''
			OR (LENGTH(?7) = 64 AND LOWER(HEX(id)) = LOWER(?7))
			OR (LENGTH(?7) < 64 AND INSTR(LOWER(HEX(id)), LOWER(?7)) > 0)
			-- TODO: consider keeping an id_hex column for faster searches
		)
		AND (
			?8 = -1
			OR (?8 = 1 AND have_results = TRUE)
			OR (?8 = 0 AND have_results = FALSE)
		)
		AND (
			?9 = -1
			OR (?9 = 1 AND final_results = TRUE)
			OR (?9 = 0 AND final_results = FALSE)
		)
		AND (
			?10 = -1
			OR (?10 = 1 AND manually_ended = TRUE)
			OR (?10 = 0 AND manually_ended = FALSE)
		)
		AND (?11 IS NULL OR start_date >= ?11)
		AND (?12 IS NULL OR start_date <= ?12)
		AND (?13 IS NULL OR end_date >= ?13)
		AND (?14 IS NULL OR end_date <= ?14)
	)
)
SELECT id, total_count
FROM results
ORDER BY creation_time DESC, id ASC
LIMIT ?2
OFFSET ?1
`

type SearchProcessesParams struct {
	Offset          int64
	Limit           int64
	EntityIDSubstr  interface{}
	Namespace       interface{}
	Status          interface{}
	SourceNetworkID interface{}
	IDSubstr        interface{}
	HaveResults     interface{}
	FinalResults    interface{}
	ManuallyEnded   interface{}
	StartDateAfter  interface{}
	StartDateBefore interface{}
	EndDateAfter    interface{}
	EndDateBefore   interface{}
}

type SearchProcessesRow struct {
	ID         []byte
	TotalCount int64
}

func (q *Queries) SearchProcesses(ctx context.Context, arg SearchProcessesParams) ([]SearchProcessesRow, error) {
	rows, err := q.query(ctx, q.searchProcessesStmt, searchProcesses,
		arg.Offset,
		arg.Limit,
		arg.EntityIDSubstr,
		arg.Namespace,
		arg.Status,
		arg.SourceNetworkID,
		arg.IDSubstr,
		arg.HaveResults,
		arg.FinalResults,
		arg.ManuallyEnded,
		arg.StartDateAfter,
		arg.StartDateBefore,
		arg.EndDateAfter,
		arg.EndDateBefore,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchProcessesRow
	for rows.Next() {
		var i SearchProcessesRow
		if err := rows.Scan(&i.ID, &i.TotalCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setProcessResultsCancelled = `-- name: SetProcessResultsCancelled :execresult
UPDATE processes
SET have_results = FALSE, final_results = TRUE, 
    end_date = ?1,
	manually_ended = ?2
WHERE id = ?3
`

type SetProcessResultsCancelledParams struct {
	EndDate       time.Time
	ManuallyEnded bool
	ID            types.ProcessID
}

func (q *Queries) SetProcessResultsCancelled(ctx context.Context, arg SetProcessResultsCancelledParams) (sql.Result, error) {
	return q.exec(ctx, q.setProcessResultsCancelledStmt, setProcessResultsCancelled, arg.EndDate, arg.ManuallyEnded, arg.ID)
}

const setProcessResultsReady = `-- name: SetProcessResultsReady :execresult
UPDATE processes
SET have_results = TRUE, final_results = TRUE,
	results_votes = ?1,
	results_weight = ?2,
	results_block_height = ?3,
	end_date = ?4
WHERE id = ?5
`

type SetProcessResultsReadyParams struct {
	Votes       string
	Weight      string
	BlockHeight int64
	EndDate     time.Time
	ID          types.ProcessID
}

func (q *Queries) SetProcessResultsReady(ctx context.Context, arg SetProcessResultsReadyParams) (sql.Result, error) {
	return q.exec(ctx, q.setProcessResultsReadyStmt, setProcessResultsReady,
		arg.Votes,
		arg.Weight,
		arg.BlockHeight,
		arg.EndDate,
		arg.ID,
	)
}

const updateProcessEndDate = `-- name: UpdateProcessEndDate :execresult
UPDATE processes
SET end_date = ?1,
	manually_ended = ?2
WHERE id = ?3
`

type UpdateProcessEndDateParams struct {
	EndDate       time.Time
	ManuallyEnded bool
	ID            types.ProcessID
}

func (q *Queries) UpdateProcessEndDate(ctx context.Context, arg UpdateProcessEndDateParams) (sql.Result, error) {
	return q.exec(ctx, q.updateProcessEndDateStmt, updateProcessEndDate, arg.EndDate, arg.ManuallyEnded, arg.ID)
}

const updateProcessFromState = `-- name: UpdateProcessFromState :execresult
UPDATE processes
SET census_root         = ?1,
	census_uri          = ?2,
	private_keys        = ?3,
	public_keys         = ?4,
	metadata            = ?5,
	status              = ?6,
	max_census_size	 	= ?7,
	end_date 			= ?8
WHERE id = ?9
`

type UpdateProcessFromStateParams struct {
	CensusRoot    types.CensusRoot
	CensusUri     string
	PrivateKeys   string
	PublicKeys    string
	Metadata      string
	Status        int64
	MaxCensusSize int64
	EndDate       time.Time
	ID            types.ProcessID
}

func (q *Queries) UpdateProcessFromState(ctx context.Context, arg UpdateProcessFromStateParams) (sql.Result, error) {
	return q.exec(ctx, q.updateProcessFromStateStmt, updateProcessFromState,
		arg.CensusRoot,
		arg.CensusUri,
		arg.PrivateKeys,
		arg.PublicKeys,
		arg.Metadata,
		arg.Status,
		arg.MaxCensusSize,
		arg.EndDate,
		arg.ID,
	)
}

const updateProcessResultByID = `-- name: UpdateProcessResultByID :execresult
UPDATE processes
SET results_votes  = ?1,
    results_weight = ?2,
    vote_opts = ?3,
    envelope = ?4
WHERE id = ?5
`

type UpdateProcessResultByIDParams struct {
	Votes    string
	Weight   string
	VoteOpts []byte
	Envelope []byte
	ID       types.ProcessID
}

func (q *Queries) UpdateProcessResultByID(ctx context.Context, arg UpdateProcessResultByIDParams) (sql.Result, error) {
	return q.exec(ctx, q.updateProcessResultByIDStmt, updateProcessResultByID,
		arg.Votes,
		arg.Weight,
		arg.VoteOpts,
		arg.Envelope,
		arg.ID,
	)
}

const updateProcessResults = `-- name: UpdateProcessResults :execresult
UPDATE processes
SET results_votes = ?1,
	results_weight = ?2,
	results_block_height = ?3
WHERE id = ?4 AND final_results = FALSE
`

type UpdateProcessResultsParams struct {
	Votes       string
	Weight      string
	BlockHeight int64
	ID          types.ProcessID
}

func (q *Queries) UpdateProcessResults(ctx context.Context, arg UpdateProcessResultsParams) (sql.Result, error) {
	return q.exec(ctx, q.updateProcessResultsStmt, updateProcessResults,
		arg.Votes,
		arg.Weight,
		arg.BlockHeight,
		arg.ID,
	)
}
